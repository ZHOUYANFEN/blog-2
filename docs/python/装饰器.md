# 装饰器

**定义：**装饰对象的器件

**作用：** 在不修改原有代码的情况下，为被装饰的对象增加新的功能或者附加限制条件或者帮助输出 

**语法：** 将@装饰器名，放在被装饰对象上面 

```
@dec
def func():
    pass
```

举个栗子：

一个基础平台已经实现了不同业务的 API 接口，现在想在不同业务上增加认证功能，该咋办？

```
# 基础平台部门开发了上百个函数API
def f1():
    print("业务部门1的数据接口......")
def f2():
    print("业务部门2的数据接口......")
def f3():
    print("业务部门3的数据接口......")
def f100():
    print("业务部门100的数据接口......")

#各部门分别调用自己需要的API
f1()
f2()
f3()
f100()
```

在不想修改内部函数的基础上，可以使用装饰器：

```
def outer(func):
    def inner():
        print("认证成功！")
        result = func()
        print("日志添加成功")
        return result
    return inner

@outer
def f1():
    print("业务部门1数据接口......")

@outer
def f2():
    print("业务部门2数据接口......")
@outer
def f3():
    print("业务部门3数据接口......")

@outer
def f100():
    print("业务部门100数据接口......")

#各部门分别调用
f1()
f2()
f3()
f100()
```

对上面的运行机制进行分析：

+ 程序从上往下执行，遇到 outer 时，将该函数装入内存但不执行
+ 执行到 @outer 时，执行的是 f1 =outer(f1)，执行 outer 函数，将返回值也就是 inner 赋给 f1 
+ 此时的 f1 不在指向之前的 f1 函数了，而是指向 inner，可以使用 f1.`__name__` 查看函数名
+ 其他的 f2 、f3 等同理
+ 执行 f1() 时，相当于执行 inner

**疑问**：为啥要在 outer 中包一个内部函数 inner ，并将该函数返回给 outer，不能直接在 outer 直接运行 f1 函数么？来试试：

```
def outer(func):
    print("认证成功！")
    result = func()
    print("日志添加成功")
    return result

@outer
def f1():
    print("业务部门1数据接口......")
    
print(f1)

结果：
认证成功！
业务部门1数据接口......
日志添加成功
None
```

按照 python 的执行顺序，可以理解：

+ 先将 outer 装入内存，不执行
+ 遇到 @outer 时，运行 f1 = outer(f1)，没有返回值
+ 由于执行 outer 时，没有返回值，所以 f1 的值为 None

解决了上面疑问，又有一个疑问：上面的 f1 函数没有参数，如果有参数的话，该如何传参呢？

**思考：**按照上面的内容得知，最终执行的是 outer 中 inner 函数，所以变量在 inner 中传参，来试下：

```
def outer(func):
    def inner(username):
        print("认证成功！")
        result = func(username)
        print("日志添加成功")
        return result
    return inner

@outer
def f1(name):
    print("%s 正在连接业务部门1数据接口......"%name)

# 调用方法
f1("jack")
```





