# 装饰器

**定义：**装饰对象的器件

**作用：** 在不修改原有代码的情况下，为被装饰的对象增加新的功能或者附加限制条件或者帮助输出 

**语法：** 将@装饰器名，放在被装饰对象上面 

```
@dec
def func():
    pass
```

举个栗子：

一个基础平台已经实现了不同业务的 API 接口，现在想在不同业务上增加认证功能，该咋办？

```
# 基础平台部门开发了上百个函数API
def f1():
    print("业务部门1的数据接口......")
def f2():
    print("业务部门2的数据接口......")
def f3():
    print("业务部门3的数据接口......")
def f100():
    print("业务部门100的数据接口......")

#各部门分别调用自己需要的API
f1()
f2()
f3()
f100()
```

在不想修改内部函数的基础上，可以使用装饰器：

```
def outer(func):
    def inner():
        print("认证成功！")
        result = func()
        print("日志添加成功")
        return result
    return inner

@outer
def f1():
    print("业务部门1数据接口......")

@outer
def f2():
    print("业务部门2数据接口......")
@outer
def f3():
    print("业务部门3数据接口......")

@outer
def f100():
    print("业务部门100数据接口......")

#各部门分别调用
f1()
f2()
f3()
f100()
```

对上面的运行机制进行分析：

+ 程序从上往下执行，遇到 outer 时，将该函数装入内存但不执行
+ 执行到 @outer 时，执行的是 f1 =outer(f1)，执行 outer 函数，将返回值也就是 inner 赋给 f1 
+ 此时的 f1 不在指向之前的 f1 函数了，而是指向 inner
+ 其他的 f2 、f3 等同理
+ 执行 f1() 时，相当于执行 inner

```pyt
def a():
	print("Tom is sing")	
f = a
f()
```

上述中是将函数对象赋值给一个变量，再通过变量调用该函数

```pyt
print(a.__name__)
print(f.__name__)  
print(id(a))
print(id(f))

输出结果：
a
a
19788248
19788248
```

由上可见，f 变量指向的就是 a 这个函数。





